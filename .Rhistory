.[. > 0] %>%           # Keep only non-zero values
sort()
pos_second_min_value <- unique(pos_non_zero_values)[2]  # The second smallest non-zero value
# Print the second smallest non-zero value
print(paste("The second smallest non-zero value is:", pos_second_min_value))
# Step 2: Replace zeros with random values between 1 and the second smallest non-zero value
set.seed(141222)  # Set seed for reproducibility
df_pos_zero_imputed <- df_pos_filtered_80 %>%
mutate(across(where(is.numeric), ~ ifelse(. == 0,
runif(1, min = 1, max = second_min_value), .)))
View(df_pos_filtered_80)
df_pos_zero_imputed <- df_pos_filtered_80 %>%
mutate(across(where(is.numeric), ~ ifelse(. == 0,
runif(1, min = 1, max = second_min_value), .)))
df_pos_zero_imputed <- df_pos_filtered_80 %>%
mutate(across(where(is.numeric), ~ ifelse(. == 0,                                             runif(1, min = 1, max = pos_second_min_value), .)))
# Step 3: Verify the replacement of zeros
# Count zeros before and after imputation
pos_zeros_before <- sum(df_pos_filtered_80 == 0, na.rm = TRUE)
pos_zeros_after <- sum(df_pos_zero_imputed == 0, na.rm = TRUE)
print(paste("Number of zeros before imputation:", pos_zeros_before))
print(paste("Number of zeros after imputation:", pos_zeros_after))
# Perform TIC normalization using the method = "sum"
pos_norm_TIC <- normalization(df_pos_zero_imputed %>% select(-Metabolite.name, -Adduct.type, -Average.Rt.min.), method = "sum")$newXtrain
# Combine normalized data with metadata
df_pos_TIC_normalized <- cbind(
df_pos_zero_imputed %>% select(Metabolite.name, Adduct.type , Average.Rt.min.),
as.data.frame(pos_norm_TIC)
)
# Verify the sums of each sample
pos_TIC_after <- colSums(df_TIC_normalized %>% select(-Metabolite.name, -Adduct.type, -Average.Rt.min.))
# Verify the sums of each sample
pos_TIC_after <- colSums(df_pos_TIC_normalized %>% select(-Metabolite.name, -Adduct.type, -Average.Rt.min.))
print("TIC values after normalization (should be ~1):")
print(pos_TIC_after)
# Check for NAs
print(paste("Number of NA values in Normalized data:", sum(is.na(pos_norm_TIC) == TRUE)))
df_pos_normalized <- df_pos_TIC_normalized
# Check for any negative values across numeric columns
any_negative <- any(df_pos_normalized  %>%
select(where(is.numeric)) %>%
unlist() < 0, na.rm = TRUE)
# Print result
if (any_negative) {
print("There are negative values in the dataframe.")
} else {
print("No negative values found in the dataframe.")
}
################################################################################
# visualization
# Prepare data for boxplot / Log2
# Prepare data for plotting (before imputation)
df_long_before <- df_filtered_80 %>%
pivot_longer(cols = -c(Metabolite.name, Average.Rt.min.), names_to = "Sample", values_to = "Intensity") %>%
mutate(Stage = "Before Imputation", Log2_Intensity = log2(Intensity + 1))  # Add log2 transformation
################################################################################
# visualization
# Prepare data for boxplot / Log2
# Prepare data for plotting (before imputation)
df_pos_long_before <- df_pos_filtered_80 %>%
pivot_longer(cols = -c(Metabolite.name, Adduct.type, Average.Rt.min.), names_to = "Sample", values_to = "Intensity") %>%
mutate(Stage = "Before Imputation", Log2_Intensity = log2(Intensity + 1))  # Add log2 transformation
# Prepare data for plotting (after imputation)
df_pos_long_after_impute <- df_pos_zero_imputed %>%
pivot_longer(cols = -c(Metabolite.name, Adduct.type, Average.Rt.min.), names_to = "Sample", values_to = "Intensity") %>%
mutate(Stage = "After Imputation", Log2_Intensity = log2(Intensity + 1))  # Add log2 transformation
# Prepare data for plotting (after normalization)
df_pos_long_after_norm <- df_pos_normalized %>%
pivot_longer(cols = -c(Metabolite.name, Adduct.type, Average.Rt.min.), names_to = "Sample", values_to = "Intensity") %>%
mutate(Stage = "After Normalization", Log2_Intensity = log2(Intensity + 1))  # Add log2 transformation
# Boxplot for before imputation
plot_before <- ggplot(df_pos_long_before, aes(x = Sample, y = Log2_Intensity)) +
geom_boxplot(outlier.alpha = 0.5, fill = "lightblue") +
labs(title = "Before Imputation", x = "Samples", y = "Log2(Intensity)") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)  # Rotate x-axis labels
)
# Boxplot for after imputation
plot_after_impute <- ggplot(df_pos_long_after_impute, aes(x = Sample, y = Log2_Intensity)) +
geom_boxplot(outlier.alpha = 0.5, fill = "lightcoral") +
labs(title = "After Imputation", x = "Samples", y = "Log2(Intensity)") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)  # Rotate x-axis labels
)
# Boxplot for after normalization
plot_after_norm <- ggplot(df_pos_long_after_norm, aes(x = Sample, y = Log2_Intensity)) +
geom_boxplot(outlier.alpha = 0.5, fill = "lightgreen") +
labs(title = "After Normalization", x = "Samples", y = "Log2(Intensity)") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)  # Rotate x-axis labels
)
# Combine the three plots using patchwork
combined_plot <- plot_before +plot_after_impute + plot_after_norm +
plot_layout(ncol = 1) & theme(legend.position = "none")
# Display the combined plot
print(combined_plot)
# Select numeric data (exclude metadata)
df_pos_scaled <- df_pos_normalized %>%
select(-Metabolite.name, -Adduct.type, -Average.Rt.min.) %>%
scale() %>%
as.data.frame()
# Combine scaled data with metadata
df_pos_scaled <- cbind(
df_pos_normalized %>% select(Metabolite.name, Adduct.type, Average.Rt.min.),
df_pos_scaled
)
# Check scaling results
summary(df_pos_scaled %>% select(-Metabolite.name, -Adduct.type, -Average.Rt.min.))
# Prepare data for PCA (exclude metadata)
pos_pca_data_scaled <- df_pos_scaled %>%
select(-Metabolite.name, -Adduct.type, -Average.Rt.min.) %>%
t() %>%
as.data.frame()
# Assign rownames to the PCA data
rownames(pos_pca_data_scaled) <- colnames(df_pos_normalized %>% select(-Metabolite.name, -Adduct.type, -Average.Rt.min.))
# Perform PCA on scaled data
pos_pca_result_scaled <- prcomp(pos_pca_data_scaleda, center = FALSE, scale. = FALSE)
# Create a data frame for plotting PCA results
pos_pca_plot_data_caled <- as.data.frame(pos_pca_result_scaled$x[, 1:2])  # Extract PC1 and PC2
# Prepare data for PCA (exclude metadata)
pos_pca_data_scaled <- df_pos_scaled %>%
select(-Metabolite.name, -Adduct.type, -Average.Rt.min.) %>%
t() %>%
as.data.frame()
# Assign rownames to the PCA data
rownames(pos_pca_data_scaled) <- colnames(df_pos_normalized %>% select(-Metabolite.name, -Adduct.type, -Average.Rt.min.))
# Perform PCA on scaled data
pos_pca_result_scaled <- prcomp(pos_pca_data_scaleda, center = FALSE, scale. = FALSE)
# Perform PCA on scaled data
pos_pca_result_scaled <- prcomp(pos_pca_data_scaled, center = FALSE, scale. = FALSE)
# Create a data frame for plotting PCA results
pos_pca_plot_data_caled <- as.data.frame(pos_pca_result_scaled$x[, 1:2])  # Extract PC1 and PC2
pos_pca_plot_data_caled$Group <- sapply(rownames(pos_pca_result_scaled), function(x) strsplit(x, "_")[[1]][1])
# Create a data frame for plotting PCA results
pos_pca_plot_data_scaled <- as.data.frame(pos_pca_result_scaled$x[, 1:2])  # Extract PC1 and PC2
pos_pca_plot_data_caled$Group <- sapply(rownames(pos_pca_result_scaled), function(x) strsplit(x, "_")[[1]][1])
pos_pca_plot_data_scaled$Group <- sapply(rownames(pos_pca_result_scaled), function(x) strsplit(x, "_")[[1]][1])
# Prepare data for PCA (exclude metadata)
pca_data <- df_pos_scaled %>%
select(-Metabolite.name, -Adduct.type, -Average.Rt.min.) %>%
t() %>%
as.data.frame()
# Assign rownames to the PCA data
rownames(pca_data) <- colnames(df_pos_normalized %>% select(-Metabolite.name,-Adduct.type, -Average.Rt.min.))
# Perform PCA on scaled data
pca_result <- prcomp(pca_data, center = FALSE, scale. = FALSE)
# Create a data frame for plotting PCA results
pca_plot_data <- as.data.frame(pca_result$x[, 1:2])  # Extract PC1 and PC2
pca_plot_data$Group <- sapply(rownames(pca_data), function(x) strsplit(x, "_")[[1]][1])
pca_plot_data$Sample <- rownames(pca_data)
# Predefined solid colors for 9 groups
solid_colors <- c(
"#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD",
"#8C564B", "#E377C2", "#7F7F7F", "#BCBD22"
)
# Dynamically map colors to groups
group_colors <- setNames(solid_colors, unique(pca_plot_data$Group))
# Step 1: Calculate variance explained by each PC
explained_variance <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pc1_var <- round(explained_variance[1] * 100, 2)  # PC1 percentage
pc2_var <- round(explained_variance[2] * 100, 2)  # PC2 percentage
pca_plot <- ggplot(pca_plot_data, aes(x = PC1, y = PC2, color = Group, label = Sample)) +
geom_point(size = 4) +
geom_text_repel(size = 3, max.overlaps = 20, box.padding = 0.5, point.padding = 0.5) +
scale_color_manual(values = group_colors) +
labs(
title = "PCA Plot with Percent Variance Explained",
x = paste0("Principal Component 1 (", pc1_var, "%)"),
y = paste0("Principal Component 2 (", pc2_var, "%)"),
color = "Group"
) +
theme_minimal() +
theme(
legend.position = "right",
legend.text = element_text(size = 10),
legend.title = element_text(size = 12),
plot.title = element_text(hjust = 0.5)
)
# Print the PCA plot
print(pca_plot)
df_neg <- read.csv("Data/NEG_Height_1_2024_09_25_03_48_22.csv", stringsAsFactors = FALSE)
df_neg_run <- df_neg %>%
filter(Metabolite.name != "Unknown",
!grepl("no MS2:", Metabolite.name),
MS.MS.matched != "FALSE")
colnames(df_neg_run)
df_neg_run_selected <- df_neg_run %>%
select(Average.Rt.min., Adduct.type , Metabolite.name,
starts_with("X240830_1137_hydrolysates_blank"),
starts_with("X240830_1137_hydrolysates_pool"),
starts_with("sample") & ends_with("_sb.cn.neg_dda1"))
colnames(df_neg_run_selected)
sample_names <- read.csv("Data/Sample_Names.txt", header = FALSE, stringsAsFactors = FALSE)
colnames(sample_names) <- c("Original", "Renamed")  # Assign meaningful column names
rename_lookup <- setNames(sample_names$Renamed, sample_names$Original)
df_neg_run_selected <- df_neg_run_selected %>%
rename_with(~ rename_lookup[gsub("_sb.cn.neg_dda1", "", .x)], .cols = contains("sample"))
df_neg_run_selected <- df_neg_run_selected %>%
rename(
Blank_1 = X240830_1137_hydrolysates_blank_sb.cn.neg_dda1,
Pool_1 = X240830_1137_hydrolysates_pool_sb.cn.neg_dda1,
Pool_2 = X240830_1137_hydrolysates_pool_sb.cn.neg_dda2
)
colnames(df_neg_run_selected) <- trimws(colnames(df_neg_run_selected))
colnames(df_neg_run_selected)
write.csv(df_neg_run_selected, "df_neg_run_selected.csv" )
df_neg_run_selected_long <- df_neg_run_selected %>%
pivot_longer(
cols = -c(Average.Rt.min., Adduct.type , Metabolite.name), # Exclude metadata columns
names_to = "Samples",
values_to = "Area"
)
ggplot(df_neg_run_selected_long, aes(x = Samples, y = Area)) +
geom_boxplot() +
geom_jitter(width=0.15)+
theme(axis.text.x = element_text(angle = 90))+
labs(x = "Samples", y = "Area", title = "Box Plot of Area by Sample")
ggplot(df_neg_run_selected_long, aes(x = Samples, y = log(Area))) +
geom_boxplot() +
geom_jitter(width = 0.15, alpha = 0.5) +  # Added alpha for better visualization of points
theme(axis.text.x = element_text(angle = 90))+
labs(x = "Samples", y = "Log10(Area)", title = "Box Plot of Log-Transformed Area by Sample")
df_neg_pca_data <- df_neg_run_selected %>%
select(-Average.Rt.min., -Adduct.type, -Metabolite.name) %>%
t() %>%
as.data.frame()
df_neg_pca_data_scaled <- scale(df_neg_pca_data)
pca_neg_result <- prcomp(df_neg_pca_data_scaled, center = TRUE, scale. = TRUE)
sample_names <- rownames(df_neg_pca_data)
group_names <- str_extract(sample_names, "^[^_]+")  # Extract the part before "_"
pca_neg_data <- data.frame(Sample = sample_names,
Group = group_names,
PC1 = pca_neg_result$x[,1],
PC2 = pca_neg_result$x[,2])
ggplot(pca_neg_data, aes(x = PC1, y = PC2, color = Group, label = Sample)) +
geom_point(size = 3) +
labs(title = "PCA Plot of Samples by Group", x = "Principal Component 1", y = "Principal Component 2") +
theme_minimal() +
theme(legend.position = "right")
# Calculate missing value percentage for each sample
neg_missing_percentage <- df_neg_run_selected %>%
select(-Average.Rt.min., -Adduct.type, -Metabolite.name) %>%  # Exclude metadata columns
summarise(across(everything(), ~ mean(is.na(.) | . == 0) * 100)) %>%  # Calculate percentage of missing values
pivot_longer(cols = everything(), names_to = "Sample", values_to = "Missing_Percentage")  # Convert to long format
ggplot(neg_missing_percentage, aes(x = Sample, y = Missing_Percentage)) +
geom_bar(stat = "identity", fill = "skyblue") +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = "Missing Value Percentage by Sample",
x = "Sample Names",
y = "Missing Value Percentage (%)")
View(df_neg_run_selected)
neg_sample_mv_columns <- names(df_neg_run_selected)[!(names(df_neg_run_selected) %in% c("Average.Rt.min.", "Adduct.type", "Metabolite.name", "Blank_1", "Pool_1", "Pool_2"))]
df_neg_mv_handle_long <- df_neg_run_selected %>%
pivot_longer(cols = all_of(neg_sample_mv_columns),
names_to = "Sample",
values_to = "Area") %>%
mutate(Group = sub("_\\d+$", "", Sample),       # Extract the base sample group name (everything before the last underscore and digit)
Replicate = as.numeric(sub(".*_", "", Sample))  # Extract replicate number (the last number after the underscore)
)
df_neg_group_counts <- df_neg_mv_handle_long %>%
group_by(Metabolite.name, Group) %>%
summarise(NonMissingCount = sum(!is.na(Area)), .groups = "drop")
neg_metabolites_to_keep <- df_neg_group_counts %>%
filter(NonMissingCount >= 2) %>%
pull(Metabolite.name) %>%
unique()  # Unique list of metabolites that meet the criteria
df_neg_filtered <- df_neg_run_selected %>%
filter(Metabolite.name %in% neg_metabolites_to_keep)
neg_metabolite_counts <- df_neg_filtered %>%
select(-Average.Rt.min., -Adduct.type, -Metabolite.name) %>%
summarise(across(everything(), ~ sum(!is.na(.)))) %>%
pivot_longer(cols = everything(), names_to = "Sample", values_to = "Count")
ggplot(neg_metabolite_counts, aes(x = Sample, y = Count)) +
geom_bar(stat = "identity", fill = "skyblue") +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = "Number of Identified Metabolites per Sample", x = "Sample", y = "Count of Identified Metabolites")
neg_missing_matrix <- df_neg_filtered %>%
select(-Average.Rt.min., -Adduct.type, -Metabolite.name) %>%
mutate(across(everything(), ~ ifelse(. == 0, 1, 0))) %>%  # Mark 0 as missing (1), others as present (0)
as.matrix()
# Double-check the binary matrix for any missing values represented as 1
table(neg_missing_matrix)
# Define color and breaks explicitly for binary data
color_palette <- c("white", "black")
breaks <- c(-0.5, 0.5, 1.5)
# Plot the heatmap
pheatmap(neg_missing_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = color_palette,
breaks = breaks,
show_rownames = FALSE,
show_colnames = TRUE,
main = "Heatmap of Missing Values Across Metabolites and Samples")
df_neg_temp <- df_neg_filtered %>%
mutate(across(everything(), ~ ifelse(. == 0, NA, .)))
vis_miss(df_neg_temp, cluster = TRUE)  # Visualize clustered missing values
# Upset plot for missing data combinations
gg_miss_upset(df_neg_temp)
# Calculate the average of blank intensities
df_neg_with_blank_avg <- df_neg_filtered %>%
rowwise() %>%
mutate(Average_Blank = mean(c_across(starts_with("Blank_")), na.rm = TRUE))
View(df_neg_with_blank_avg)
# Step 2: Subtract Blank Values from Samples
# Define the sample columns (exclude metadata and blank columns)
sample_columns <- setdiff(names(df_neg_with_blank_avg),
c("Metabolite.name", "Adduct.type", "Average.Rt.min.", "Blank_1", "Pool_1", "Pool_2", "Average_Blank"))
# Subtract blanks and replace negatives with zero
df_neg_blank_corrected <- df_neg_with_blank_avg %>%
mutate(across(all_of(sample_columns), ~ ifelse((. - Average_Blank) < 0, 0, . - Average_Blank))) %>%
select(-starts_with("Blank_"), -starts_with("Pool_"), -Average_Blank)  # Drop Blank, Pool, and Average_Blank columns
################################################################################
# Check for any negative values across numeric columns
any_negative <- any(df_neg_blank_corrected %>%
select(where(is.numeric)) %>%
unlist() < 0, na.rm = TRUE)
# Print result
if (any_negative) {
print("There are negative values in the dataframe.")
} else {
print("No negative values found in the dataframe.")
}
# Identify metabolites with >20% zero values in samples
neg_metabolites_to_keep <- df_neg_blank_corrected %>%
select(-Metabolite.name, -Adduct.type, -Average.Rt.min.) %>%
summarise(across(everything(), ~ mean(. == 0, na.rm = TRUE))) %>%
pivot_longer(cols = everything(),
names_to = "Sample",
values_to = "Zero_Percentage") %>%
filter(Zero_Percentage <= 0.20) %>%
pull(Sample)
# Filter the dataset to keep only those metabolites
df_neg_filtered_80 <- df_neg_blank_corrected %>%
select(Metabolite.name,
Adduct.type,
Average.Rt.min.,
all_of(neg_metabolites_to_keep))
################################################################################
## Visualize missing values
# Prepare the dataset for heatmap
# Remove metadata columns (Metabolite.name, Average.Rt.min.)
neg_heatmap_data <- df_neg_filtered_80 %>%
select(-Metabolite.name, -Adduct.type, -Average.Rt.min.)
# Create a binary-like matrix for coloring: 0 stays as 0, all other values become 1
neg_binary_heatmap_data <- neg_heatmap_data %>%
mutate(across(everything(), ~ ifelse(. == 0, 0, 1))) %>%
as.matrix()
# Define color palette and breaks for binary data
color_palette <- c("black", "lightblue") # Black for 0, light blue for all other values
breaks <- c(-0.5, 0.5, 1.5) # Ensure two distinct bins: 0 and non-zero values
# Plot the heatmap
pheatmap(
neg_binary_heatmap_data,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = color_palette,
breaks = breaks,
main = "Two-Color Heatmap of Zero Patterns in df_filtered_80",
show_rownames = FALSE,
show_colnames = TRUE
)
# Step 1: Identify the second smallest non-zero value
# Flatten all numeric data, filter out zeros, and get the second smallest value
neg_non_zero_values <- df_neg_filtered_80 %>%
select(where(is.numeric)) %>%
unlist() %>%
.[. > 0] %>%           # Keep only non-zero values
sort()
neg_second_min_value <- unique(neg_non_zero_values)[2]  # The second smallest non-zero value
# Print the second smallest non-zero value
print(paste("The second smallest non-zero value is:", pos_second_min_value))
# Print the second smallest non-zero value
print(paste("The second smallest non-zero value is:", neg_second_min_value))
# Step 2: Replace zeros with random values between 1 and the second smallest non-zero value
set.seed(141222)  # Set seed for reproducibility
df_neg_zero_imputed <- df_neg_filtered_80 %>%
mutate(across(where(is.numeric), ~ ifelse(. == 0,                                             runif(1, min = 1, max = neg_second_min_value), .)))
# Step 3: Verify the replacement of zeros
# Count zeros before and after imputation
neg_zeros_before <- sum(df_neg_filtered_80 == 0, na.rm = TRUE)
neg_zeros_after <- sum(df_neg_zero_imputed == 0, na.rm = TRUE)
print(paste("Number of zeros before imputation:", neg_zeros_before))
print(paste("Number of zeros after imputation:", neg_zeros_after))
# Perform TIC normalization using the method = "sum"
neg_norm_TIC <- normalization(df_neg_zero_imputed %>% select(-Metabolite.name, -Adduct.type, -Average.Rt.min.), method = "sum")$newXtrain
# Combine normalized data with metadata
df_neg_TIC_normalized <- cbind(
df_neg_zero_imputed %>% select(Metabolite.name, Adduct.type , Average.Rt.min.),
as.data.frame(neg_norm_TIC)
)
# Verify the sums of each sample
neg_TIC_after <- colSums(df_neg_TIC_normalized %>% select(-Metabolite.name, -Adduct.type, -Average.Rt.min.))
print("TIC values after normalization (should be ~1):")
print(neg_TIC_after)
# Check for NAs
print(paste("Number of NA values in Normalized data:", sum(is.na(neg_norm_TIC) == TRUE)))
df_neg_normalized <- df_neg_TIC_normalized
# Check for any negative values across numeric columns
any_negative <- any(df_neg_normalized  %>%
select(where(is.numeric)) %>%
unlist() < 0, na.rm = TRUE)
# Print result
if (any_negative) {
print("There are negative values in the dataframe.")
} else {
print("No negative values found in the dataframe.")
}
################################################################################
# visualization
# Prepare data for boxplot / Log2
# Prepare data for plotting (before imputation)
df_neg_long_before <- df_neg_filtered_80 %>%
pivot_longer(cols = -c(Metabolite.name, Adduct.type, Average.Rt.min.), names_to = "Sample", values_to = "Intensity") %>%
mutate(Stage = "Before Imputation", Log2_Intensity = log2(Intensity + 1))  # Add log2 transformation
# Prepare data for plotting (after imputation)
df_neg_long_after_impute <- df_neg_zero_imputed %>%
pivot_longer(cols = -c(Metabolite.name, Adduct.type, Average.Rt.min.), names_to = "Sample", values_to = "Intensity") %>%
mutate(Stage = "After Imputation", Log2_Intensity = log2(Intensity + 1))  # Add log2 transformation
# Prepare data for plotting (after normalization)
df_neg_long_after_norm <- df_neg_normalized %>%
pivot_longer(cols = -c(Metabolite.name, Adduct.type, Average.Rt.min.), names_to = "Sample", values_to = "Intensity") %>%
mutate(Stage = "After Normalization", Log2_Intensity = log2(Intensity + 1))  # Add log2 transformation
# Boxplot for before imputation
plot_before <- ggplot(df_neg_long_before, aes(x = Sample, y = Log2_Intensity)) +
geom_boxplot(outlier.alpha = 0.5, fill = "lightblue") +
labs(title = "Before Imputation", x = "Samples", y = "Log2(Intensity)") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)  # Rotate x-axis labels
)
# Boxplot for after imputation
plot_after_impute <- ggplot(df_neg_long_after_impute, aes(x = Sample, y = Log2_Intensity)) +
geom_boxplot(outlier.alpha = 0.5, fill = "lightcoral") +
labs(title = "After Imputation", x = "Samples", y = "Log2(Intensity)") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)  # Rotate x-axis labels
)
# Boxplot for after normalization
plot_after_norm <- ggplot(df_neg_long_after_norm, aes(x = Sample, y = Log2_Intensity)) +
geom_boxplot(outlier.alpha = 0.5, fill = "lightgreen") +
labs(title = "After Normalization", x = "Samples", y = "Log2(Intensity)") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)  # Rotate x-axis labels
)
# Combine the three plots using patchwork
combined_plot <- plot_before +plot_after_impute + plot_after_norm +
plot_layout(ncol = 1) & theme(legend.position = "none")
# Display the combined plot
print(combined_plot)
# Select numeric data (exclude metadata)
df_neg_scaled <- df_neg_normalized %>%
select(-Metabolite.name, -Adduct.type, -Average.Rt.min.) %>%
scale() %>%
as.data.frame()
# Combine scaled data with metadata
df_neg_scaled <- cbind(
df_neg_normalized %>% select(Metabolite.name, Adduct.type, Average.Rt.min.),
df_neg_scaled
)
# Check scaling results
summary(df_neg_scaled %>% select(-Metabolite.name, -Adduct.type, -Average.Rt.min.))
# Prepare data for PCA (exclude metadata)
pca_data <- df_neg_scaled %>%
select(-Metabolite.name, -Adduct.type, -Average.Rt.min.) %>%
t() %>%
as.data.frame()
# Assign rownames to the PCA data
rownames(pca_data) <- colnames(df_neg_normalized %>% select(-Metabolite.name,-Adduct.type, -Average.Rt.min.))
# Perform PCA on scaled data
pca_result <- prcomp(pca_data, center = FALSE, scale. = FALSE)
# Create a data frame for plotting PCA results
pca_plot_data <- as.data.frame(pca_result$x[, 1:2])  # Extract PC1 and PC2
pca_plot_data$Group <- sapply(rownames(pca_data), function(x) strsplit(x, "_")[[1]][1])
pca_plot_data$Sample <- rownames(pca_data)
# Predefined solid colors for 9 groups
solid_colors <- c(
"#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD",
"#8C564B", "#E377C2", "#7F7F7F", "#BCBD22"
)
# Dynamically map colors to groups
group_colors <- setNames(solid_colors, unique(pca_plot_data$Group))
# Step 1: Calculate variance explained by each PC
explained_variance <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pc1_var <- round(explained_variance[1] * 100, 2)  # PC1 percentage
pc2_var <- round(explained_variance[2] * 100, 2)  # PC2 percentage
pca_plot <- ggplot(pca_plot_data, aes(x = PC1, y = PC2, color = Group, label = Sample)) +
geom_point(size = 4) +
geom_text_repel(size = 3, max.overlaps = 20, box.padding = 0.5, point.padding = 0.5) +
scale_color_manual(values = group_colors) +
labs(
title = "PCA Plot with Percent Variance Explained",
x = paste0("Principal Component 1 (", pc1_var, "%)"),
y = paste0("Principal Component 2 (", pc2_var, "%)"),
color = "Group"
) +
theme_minimal() +
theme(
legend.position = "right",
legend.text = element_text(size = 10),
legend.title = element_text(size = 12),
plot.title = element_text(hjust = 0.5)
)
# Print the PCA plot
print(pca_plot)
write.csv( df_neg_normalized, "df_neg_normalized.csv")
colnames(df_neg_normalized)
