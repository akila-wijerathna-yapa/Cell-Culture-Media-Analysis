normalized_data <- as.data.frame(exprs(vsn_normalized))
normalized_data$Metabolite.name <- df_filtered_imputed$Metabolite.name
# Convert normalized data to long format for plotting
df_long_normalized <- normalized_data %>%
pivot_longer(cols = -Metabolite.name, names_to = "Sample", values_to = "Area")
# Step 4: Plot boxplot of normalized data
plot_normalized <- ggplot(df_long_normalized, aes(x = Area, y = Sample)) +
geom_boxplot(fill = "lightgreen") +
theme(axis.text.y = element_text(angle = 0)) +
labs(title = "Boxplot of Metabolite Areas (After VSN Normalization)", y = "Sample", x = "VSN Normalized Area")
# Step 5: Combine plots with patchwork (top: raw data, bottom: normalized data)
combined_plot <- plot_raw / plot_normalized  # Stack the plots vertically
# Step 1: Prepare data for visualization (before normalization)
df_long_raw <- df_filtered_imputed %>%
pivot_longer(cols = -c(Average_Rt_min_, Metabolite_name), names_to = "Sample", values_to = "Area")
# Step 2: Plot boxplot of raw data using log2 transformation
plot_raw <- ggplot(df_long_raw, aes(x = log2(Area + 1), y = Sample)) +  # log2 transformation for visualization
geom_boxplot(fill = "lightblue") +
theme(axis.text.y = element_text(angle = 0)) +
labs(title = "Boxplot of Metabolite Areas (Before Normalization)", y = "Sample", x = "Log2(Area + 1)")
# Step 3: Apply VSN normalization on df_filtered_imputed
# Ensure the selection excludes Average_Rt_min_ and Metabolite_name columns
data_matrix <- as.matrix(df_filtered_imputed %>% select(-Average_Rt_min_, -Metabolite_name))
vsn_normalized <- vsn::vsn2(data_matrix)
# Extract normalized data
normalized_data <- as.data.frame(exprs(vsn_normalized))
normalized_data$Metabolite_name <- df_filtered_imputed$Metabolite_name  # Add back Metabolite names for plotting
# Step 4: Convert normalized data to long format for plotting
df_long_normalized <- normalized_data %>%
pivot_longer(cols = -Metabolite_name, names_to = "Sample", values_to = "Area")
# Plot boxplot of normalized data
plot_normalized <- ggplot(df_long_normalized, aes(x = Area, y = Sample)) +
geom_boxplot(fill = "lightgreen") +
theme(axis.text.y = element_text(angle = 0)) +
labs(title = "Boxplot of Metabolite Areas (After VSN Normalization)", y = "Sample", x = "VSN Normalized Area")
# Step 5: Combine plots with patchwork (top: raw data, bottom: normalized data)
combined_plot <- plot_raw / plot_normalized  # Stack the plots vertically
print(combined_plot)
# Step 1: Select sample columns (excluding metadata) for PCA
df_pca_data <- df_filtered_imputed %>%
select(-Average_Rt_min_, -Metabolite_name) %>%
t() %>%
as.data.frame()
# Standardize the data (mean=0, variance=1) for PCA
df_pca_data_scaled <- scale(df_pca_data)
# Step 2: Perform PCA
pca_result <- prcomp(df_pca_data_scaled, center = TRUE, scale. = TRUE)
str(df_pca_data_scaled)
sum(is.na(df_pca_data_scaled))  # Count NA values
sum(is.infinite(df_pca_data_scaled))  # Count Inf values
sum(is.na(df_filtered_imputed))
# Step 1: Convert 0s to NAs in the dataset (if 0 represents missing values)
df_temp <- df_filtered %>%
mutate(across(where(is.numeric), ~ ifelse(. == 0, NA, .)))  # Target only numeric columns
# Step 2: Re-apply k-NN imputation specifically on numeric data columns
# Ensure we use only the numeric columns from df_temp in the imputation
df_filtered_imputed <- impute_knn(df_temp %>% select(where(is.numeric)), k = 10)
library(simputation)
# Step 1: Convert 0s to NAs in the dataset (if 0 represents missing values)
df_temp <- df_filtered %>%
mutate(across(where(is.numeric), ~ ifelse(. == 0, NA, .)))  # Target only numeric columns
# Step 2: Re-apply k-NN imputation specifically on numeric data columns
# Ensure we use only the numeric columns from df_temp in the imputation
df_filtered_imputed <- impute_knn(df_temp %>% select(where(is.numeric)), k = 10)
# Step 1: Convert 0s to NAs in the dataset (if 0 represents missing values)
df_temp <- df_filtered %>%
mutate(across(where(is.numeric), ~ ifelse(. == 0, NA, .)))  # Target only numeric columns
# Step 2: Apply k-NN imputation with a generic formula
df_filtered_imputed <- impute_knn(df_temp, formula = ~ ., k = 10)
# Step 3: Verify that imputation has been completed
remaining_NA_count <- sum(is.na(df_filtered_imputed))  # Should be 0 if imputation is complete
print(remaining_NA_count)
# Step 1: Convert 0s to NAs in the dataset (if 0 represents missing values)
df_temp <- df_filtered %>%
mutate(across(where(is.numeric), ~ ifelse(. == 0, NA, .)))  # Target only numeric columns
# Step 2: Confirm the presence of NAs after conversion
converted_na_count <- sum(is.na(df_temp))
print(paste("NA count after conversion:", converted_na_count))
# Step 3: Reapply k-NN imputation specifically to only the columns with remaining NA values
df_filtered_imputed <- impute_knn(df_temp, formula = ~ ., k = 10)
# Step 4: Verify that imputation has been completed
remaining_NA_count <- sum(is.na(df_filtered_imputed))  # Should be 0 if imputation is complete
print(paste("Remaining NA count after imputation:", remaining_NA_count))
# Find the minimum non-zero value across the dataset
min_value <- min(df_filtered[df_filtered > 0], na.rm = TRUE)
min_value
# Verify the result
sum(is.na(df_filtered_imputed))
# Replace both 0s and NAs with 1 in numeric columns only
df_filtered_imputed <- df_filtered %>%
mutate(across(where(is.numeric), ~ ifelse(is.na(.) | . == 0, 1, .)))
# Verify if all NAs and 0s are replaced
sum(is.na(df_filtered_imputed))  # Should be 0 if imputation is complete
# Verify the result
sum(is.na(df_filtered_imputed))  # Should be 0 if imputation is complete
# Prepare data as before
df_temp_long <- df_temp %>%
pivot_longer(cols = starts_with("Blank") | starts_with("Hy") | starts_with("Pool"),
names_to = "Sample", values_to = "Area") %>%
mutate(Log2_Area = log2(Area + 1),  # Add 1 to avoid log of zero
Source = "Before Imputation")
df_filtered_imputed_long <- df_filtered_imputed %>%
pivot_longer(cols = starts_with("Blank") | starts_with("Hy") | starts_with("Pool"),
names_to = "Sample", values_to = "Area") %>%
mutate(Log2_Area = log2(Area + 1),
Source = "After Imputation")
# Combine both data frames for plotting
df_combined <- bind_rows(df_temp_long, df_filtered_imputed_long)
# Plot with faceting
ggplot(df_combined, aes(x = Log2_Area)) +
geom_density(color = "blue", size = 1) +  # Set line color and thickness
labs(title = "Density Plot of Log2 Area Before and After Imputation",
x = "Log2(Area)",
y = "Density") +
facet_wrap(~ Source, ncol = 1) +  # Separate plots vertically by Source
theme_minimal() +
theme(strip.text = element_text(size = 12),  # Adjust facet title font size
legend.position = "none")
# Load necessary libraries
library(vsn)
library(patchwork)
# Step 1: Prepare data for visualization (before normalization)
df_long_raw <- df_filtered_imputed %>%
pivot_longer(cols = -c(Average_Rt_min_, Metabolite_name), names_to = "Sample", values_to = "Area")
# Step 2: Plot boxplot of raw data using log2 transformation
plot_raw <- ggplot(df_long_raw, aes(x = log2(Area + 1), y = Sample)) +  # log2 transformation for visualization
geom_boxplot(fill = "lightblue") +
theme(axis.text.y = element_text(angle = 0)) +
labs(title = "Boxplot of Metabolite Areas (Before Normalization)", y = "Sample", x = "Log2(Area + 1)")
# Step 3: Apply VSN normalization on df_filtered_imputed
# Ensure the selection excludes Average_Rt_min_ and Metabolite_name columns
data_matrix <- as.matrix(df_filtered_imputed %>% select(-Average_Rt_min_, -Metabolite_name))
vsn_normalized <- vsn::vsn2(data_matrix)
# Extract normalized data
normalized_data <- as.data.frame(exprs(vsn_normalized))
normalized_data$Metabolite_name <- df_filtered_imputed$Metabolite_name  # Add back Metabolite names for plotting
# Step 4: Convert normalized data to long format for plotting
df_long_normalized <- normalized_data %>%
pivot_longer(cols = -Metabolite_name, names_to = "Sample", values_to = "Area")
# Plot boxplot of normalized data
plot_normalized <- ggplot(df_long_normalized, aes(x = Area, y = Sample)) +
geom_boxplot(fill = "lightgreen") +
theme(axis.text.y = element_text(angle = 0)) +
labs(title = "Boxplot of Metabolite Areas (After VSN Normalization)", y = "Sample", x = "VSN Normalized Area")
# Step 5: Combine plots with patchwork (top: raw data, bottom: normalized data)
combined_plot <- plot_raw / plot_normalized  # Stack the plots vertically
print(combined_plot)
sum(is.na(df_pca_data_scaled))  # Count NA values
sum(is.na(df_filtered_imputed))  # Count NA values
# Step 1: Select sample columns (excluding metadata) for PCA
df_pca_data <- df_filtered_imputed %>%
select(-Average_Rt_min_, -Metabolite_name) %>%
t() %>%
as.data.frame()
# Standardize the data (mean=0, variance=1) for PCA
df_pca_data_scaled <- scale(df_pca_data)
# Step 2: Perform PCA
pca_result <- prcomp(df_pca_data_scaled, center = TRUE, scale. = TRUE)
# Step 3: Extract sample names and group by ignoring replicate numbers
sample_names <- rownames(df_pca_data)
group_names <- str_extract(sample_names, "^[^_]+")  # Extract the part before "_"
# Step 4: Create a data frame with PCA results and group labels
pca_data <- data.frame(Sample = sample_names,
Group = group_names,
PC1 = pca_result$x[,1],
PC2 = pca_result$x[,2])
# Step 5: Plot the PCA results with colors based on sample groups
ggplot(pca_data, aes(x = PC1, y = PC2, color = Group, label = Sample)) +
geom_point(size = 3) +
labs(title = "PCA Plot of Samples by Group", x = "Principal Component 1", y = "Principal Component 2") +
theme_minimal() +
theme(legend.position = "right")
View(df_filtered_imputed)
# Step 1: Select sample columns (excluding metadata) for PCA
df_pca_data <- df_filtered_imputed %>%
select(-Average_Rt_min_, -Metabolite_name) %>%
t() %>%
as.data.frame()
# Standardize the data (mean=0, variance=1) for PCA
df_pca_data_scaled <- scale(df_pca_data)
# Step 2: Perform PCA
pca_result <- prcomp(df_pca_data_scaled, center = TRUE, scale. = TRUE)
# Step 3: Extract sample names
sample_names <- rownames(df_pca_data)
# Step 4: Create a data frame with PCA results
pca_data <- data.frame(Sample = sample_names,
PC1 = pca_result$x[,1],
PC2 = pca_result$x[,2])
# Step 5: Plot the PCA results without grouping
ggplot(pca_data, aes(x = PC1, y = PC2, label = Sample)) +
geom_point(size = 3, color = "blue") +
labs(title = "PCA Plot of Samples", x = "Principal Component 1", y = "Principal Component 2") +
theme_minimal() +
theme(legend.position = "none")
colnames(df_filtered_imputed)
# Step 1: Select sample columns (excluding metadata) for PCA
df_pca_data <- df_filtered_imputed %>%
select(-Average_Rt_min_, -Metabolite_name) %>%
t() %>%
as.data.frame()
# Standardize the data (mean=0, variance=1) for PCA
df_pca_data_scaled <- scale(df_pca_data)
# Step 2: Perform PCA
pca_result <- prcomp(df_pca_data_scaled, center = TRUE, scale. = TRUE)
# Step 3: Extract sample names and group by keeping the full prefix for "HY_YEST" samples
sample_names <- rownames(df_pca_data)
group_names <- ifelse(grepl("^HY_YEST", sample_names),
str_extract(sample_names, "^[^_]+_[^_]+"),  # Extract "HY_YEST" as one unit
str_extract(sample_names, "^[^_]+"))       # Extract first part for others
# Step 4: Create a data frame with PCA results and group labels
pca_data <- data.frame(Sample = sample_names,
Group = group_names,
PC1 = pca_result$x[,1],
PC2 = pca_result$x[,2])
# Step 5: Plot the PCA results with color by group and labeled sample names
ggplot(pca_data, aes(x = PC1, y = PC2, color = Group, label = Sample)) +
geom_point(size = 3) +
geom_text(aes(label = Sample), hjust = 1.1, vjust = 1.1, size = 2.5, check_overlap = TRUE) +  # Adjust text size and placement
labs(title = "PCA Plot of Samples by Group", x = "Principal Component 1", y = "Principal Component 2") +
theme_minimal() +
theme(legend.position = "right")
# Step 6: Prepare the imputed data for visualization (before normalization)
df_long_raw <- df_filtered_imputed %>%
pivot_longer(cols = -c(Average_Rt_min_, Metabolite_name), names_to = "Sample", values_to = "Area")
# Step 7: Plot boxplot of raw data using log2 transformation
plot_raw <- ggplot(df_long_raw, aes(x = log2(Area + 1), y = Sample)) +  # log2 transformation for visualization
geom_boxplot(fill = "lightblue") +
theme(axis.text.y = element_text(angle = 0)) +
labs(title = "Boxplot of Metabolite Areas (Before Normalization)", y = "Sample", x = "Log2(Area + 1)")
# Step 8: Apply VSN normalization on df_filtered_imputed
data_matrix <- as.matrix(df_filtered_imputed %>% select(-Average_Rt_min_, -Metabolite_name))
vsn_normalized <- vsn::vsn2(data_matrix)
vsn
# Step 6: Prepare the imputed data for visualization (before normalization)
df_long_raw <- df_filtered_imputed %>%
pivot_longer(cols = -c(Average_Rt_min_, Metabolite_name), names_to = "Sample", values_to = "Area")
# Step 7: Plot boxplot of raw data using log2 transformation
plot_raw <- ggplot(df_long_raw, aes(x = log2(Area + 1), y = Sample)) +  # log2 transformation for visualization
geom_boxplot(fill = "lightblue") +
theme(axis.text.y = element_text(angle = 0)) +
labs(title = "Boxplot of Metabolite Areas (Before Normalization)", y = "Sample", x = "Log2(Area + 1)")
# Step 8: Apply VSN normalization on df_filtered_imputed
data_matrix <- as.matrix(df_filtered_imputed %>% select(-Average_Rt_min_, -Metabolite_name))
vsn_normalized <- vsn::vsn2(data_matrix)
# Extract normalized data and convert it for plotting
normalized_data <- as.data.frame(exprs(vsn_normalized))
normalized_data$Metabolite_name <- df_filtered_imputed$Metabolite_name
df_long_normalized <- normalized_data %>%
pivot_longer(cols = -Metabolite_name, names_to = "Sample", values_to = "Area")
# Step 9: Plot boxplot of normalized data
plot_normalized <- ggplot(df_long_normalized, aes(x = Area, y = Sample)) +
geom_boxplot(fill = "lightgreen") +
theme(axis.text.y = element_text(angle = 0)) +
labs(title = "Boxplot of Metabolite Areas (After VSN Normalization)", y = "Sample", x = "VSN Normalized Area")
# Step 10: Combine plots with patchwork (top: raw data, bottom: normalized data)
combined_plot <- plot_raw / plot_normalized  # Stack the plots vertically
print(combined_plot)
View(normalized_data)
str(normalized_data )
# Convert normalized data to long format for ggplot2
df_long_normalized <- normalized_data %>%
pivot_longer(cols = -Metabolite_name, names_to = "Sample", values_to = "Area")
# Plot the box plot with log-transformed data
ggplot(df_long_normalized, aes(x = Sample, y = log10(Area))) +
geom_boxplot(fill = "lightgreen") +
geom_jitter(width = 0.15, alpha = 0.5, color = "blue") +  # Optional: Color jitter for better contrast
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(x = "Samples", y = "Log10(Area)", title = "Box Plot of Log-Transformed Area by Sample (Normalized Data)")
# Plot the box plot with log-transformed data
ggplot(df_long_normalized, aes(x = Sample, y = log2(Area))) +
geom_boxplot(fill = "lightgreen") +
geom_jitter(width = 0.15, alpha = 0.5, color = "blue") +  # Optional: Color jitter for better contrast
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(x = "Samples", y = "Log10(Area)", title = "Box Plot of Log-Transformed Area by Sample (Normalized Data)")
# Define blank columns
blank_columns <- c("Blank_1", "Blank_2", "Blank_3", "Blank_4")
# Calculate Q3 thresholds for each blank sample in normalized_data
blank_thresholds <- normalized_data %>%
select(all_of(blank_columns)) %>%
summarise(across(everything(), ~ quantile(.x, 0.75, na.rm = TRUE)))
# Step 1: Retrieve the list of metabolite names from df_below_Q3
metabolites_below_Q3 <- df_below_Q3$Metabolite.name
# Transform normalized_data to long format and flag values above Q3
df_normalized_data_long <- normalized_data %>%
pivot_longer(cols = -Metabolite_name, names_to = "Samples", values_to = "Area") %>%
mutate(flag = case_when(
Samples == "Blank_1" & Area > blank_thresholds$Blank_1 ~ "Above Q3",
Samples == "Blank_2" & Area > blank_thresholds$Blank_2 ~ "Above Q3",
Samples == "Blank_3" & Area > blank_thresholds$Blank_3 ~ "Above Q3",
Samples == "Blank_4" & Area > blank_thresholds$Blank_4 ~ "Above Q3",
TRUE ~ "Below Q3"
))
ggplot(df_normalized_data_long, aes(x = Samples, y = log10(Area))) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(aes(color = flag), width = 0.15, alpha = 0.5) +
scale_color_manual(values = c("Above Q3" = "red", "Below Q3" = "black")) +
theme(axis.text.x = element_text(angle = 90)) +
labs(x = "Samples", y = "Log10(Area)", title = "Box Plot of Log10(Area) by Sample with Flagged Metabolites")
# Step 4. Filter for Metabolites Below Q3 in All Blanks
# Identify metabolites below Q3 in all blanks
below_Q3_metabolites <- normalized_data %>%
rowwise() %>%
filter(all(c_across(all_of(blank_columns)) <= blank_thresholds)) %>%
pull(Metabolite_name)
# Filter data to keep only below Q3 metabolites
df_below_Q3 <- normalized_data %>%
filter(Metabolite_name %in% below_Q3_metabolites)
# Step 5. Create New PCA with df_below_Q3
# Prepare data for PCA by selecting sample columns
df_pca_data <- df_below_Q3 %>%
select(-Metabolite_name) %>%
t() %>%
as.data.frame()
# Standardize and perform PCA
df_pca_data_scaled <- scale(df_pca_data)
pca_result <- prcomp(df_pca_data_scaled, center = TRUE, scale. = TRUE)
# Extract sample names and groups
sample_names <- rownames(df_pca_data)
group_names <- ifelse(grepl("^HY_YEST", sample_names),
str_extract(sample_names, "^[^_]+_[^_]+"),
str_extract(sample_names, "^[^_]+"))
# Create PCA plot with color based on group
pca_data <- data.frame(Sample = sample_names, Group = group_names, PC1 = pca_result$x[,1], PC2 = pca_result$x[,2])
ggplot(pca_data, aes(x = PC1, y = PC2, color = Group, label = Sample)) +
geom_point(size = 3) +
labs(title = "PCA Plot of Samples by Group (Below Q3 Metabolites)", x = "Principal Component 1", y = "Principal Component 2") +
theme_minimal() +
theme(legend.position = "right")
below_Q3_metabolites
# Step 1: Calculate the average of the blank columns for each metabolite
df_with_blank_avg <- df_below_Q3 %>%
rowwise() %>%
mutate(Average_Blank = mean(c_across(starts_with("Blank_")), na.rm = TRUE))
# Step 2: Define sample columns, excluding `Pool_1` and `Pool_2`
sample_columns <- setdiff(names(df_below_Q3), c("Average.Rt.min.", "Metabolite.name", "Blank_1", "Blank_2", "Blank_3", "Blank_4", "Pool_1", "Pool_2"))
# Step 3: Subtract the average blank value from each sample column and create the new data frame
df_clean_to_stat <- df_with_blank_avg %>%
mutate(across(all_of(sample_columns), ~ . - Average_Blank)) %>%
select(Metabolite.name, all_of(sample_columns))
View(df_below_Q3)
# Step 1: Calculate the average of the blank columns for each metabolite in df_below_Q3
df_with_blank_avg <- df_below_Q3 %>%
rowwise() %>%
mutate(Average_Blank = mean(c_across(starts_with("Blank_")), na.rm = TRUE))
# Step 2: Define sample columns, excluding `Pool_1`, `Pool_2`, and all `Blank` columns
sample_columns <- setdiff(names(df_below_Q3), c("Metabolite_name", "Blank_1", "Blank_2", "Blank_3", "Blank_4", "Pool_1", "Pool_2"))
# Step 3: Subtract the average blank value from each sample column to remove background noise
df_clean_to_stat <- df_with_blank_avg %>%
mutate(across(all_of(sample_columns), ~ . - Average_Blank)) %>%
select(Metabolite_name, all_of(sample_columns))  # Keep only the relevant columns for downstream analysis
View(df_clean_to_stat)
# View the resulting dataframe
str(df_clean_to_stat)
# Step 1: Clean the `Metabolite.name` by removing extra information after ";"
df_clean_to_stat <- df_clean_to_stat %>%
mutate(Metabolite.name = sub(";.*", "", Metabolite.name))
View(df_below_Q3)
# Step 1: Clean the `Metabolite.name` by removing extra information after ";"
df_clean_to_stat <- df_clean_to_stat %>%
mutate(Metabolite_name = sub(";.*", "", Metabolite.name))
# Step 1: Clean the `Metabolite.name` by removing extra information after ";"
df_clean_to_stat <- df_clean_to_stat %>%
mutate(Metabolite.name = sub(";.*", "", Metabolite_name))
# Step 2: Group by the cleaned `Metabolite.name` and calculate the average for each unique metabolite
df_clean_to_stat_v1 <- df_clean_to_stat %>%
group_by(Metabolite.name) %>%
summarise(across(everything(), mean, na.rm = TRUE)) %>%
ungroup()
# View the resulting dataframe
str(df_clean_to_stat_v1)
# Step 1: Reshape to long format to handle replicate averaging without creating duplicate column names
df_long <- df_clean_to_stat_v1 %>%
pivot_longer(cols = -Metabolite.name, names_to = "Sample", values_to = "Value")
# Step 2: Extract base sample names by removing replicate suffixes
df_long <- df_long %>%
mutate(Base_Sample = str_remove(Sample, "_\\d+$"))
# Step 3: Group by Metabolite.name and Base_Sample, then calculate the average for each base sample
df_clean_to_stat_v2 <- df_long %>%
group_by(Metabolite.name, Base_Sample) %>%
summarise(Average_Value = mean(Value, na.rm = TRUE), .groups = "drop")  # Calculate mean across replicates
# Step 4: Pivot back to wide format to get a final data frame with averaged values for each base sample
df_clean_to_stat_v2 <- df_clean_to_stat_v2 %>%
pivot_wider(names_from = Base_Sample, values_from = Average_Value)
# View the resulting dataframe
str(df_clean_to_stat_v2)
# Step 1: Truncate Metabolite.name to the first 30 characters
df_clean_to_stat_v2 <- df_clean_to_stat_v2 %>%
mutate(Metabolite.name = str_sub(Metabolite.name, 1, 30))
# Step 2: Prepare the data matrix for the heatmap
# Remove the Metabolite.name column and convert the data to a matrix
heatmap_matrix <- df_clean_to_stat_v2 %>%
column_to_rownames(var = "Metabolite.name") %>%
as.matrix()
# Step 3a: Save heatmap as a PDF with high resolution
pdf("Heatmap_Metabolite_Data.pdf", width = 12, height = 10)  # Set appropriate width and height
pheatmap(heatmap_matrix,
scale = "row",  # Normalize each row for better visualization
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(50),
main = "Heatmap of Metabolite Data (Averaged Across Replicates)",
fontsize_row = 6)  # Adjust font size for row labels
dev.off()
# Step 1: Calculate the average of the blank columns for each metabolite in df_below_Q3
df_with_blank_avg <- df_below_Q3 %>%
rowwise() %>%
mutate(Average_Blank = mean(c_across(starts_with("Blank_")), na.rm = TRUE))
# Step 2: Define sample columns, excluding `Pool_1`, `Pool_2`, and all `Blank` columns
sample_columns <- setdiff(names(df_below_Q3), c("Metabolite_name", "Blank_1", "Blank_2", "Blank_3", "Blank_4", "Pool_1", "Pool_2"))
# Step 3: Subtract the average blank value from each sample column to remove background noise
df_clean_to_stat <- df_with_blank_avg %>%
mutate(across(all_of(sample_columns), ~ . - Average_Blank)) %>%
select(Metabolite_name, all_of(sample_columns))  # Keep only the relevant columns for downstream analysis
# View the resulting dataframe
str(df_clean_to_stat)
View(df_clean_to_stat)
# Step 1: Clean the `Metabolite.name` by removing extra information after ";"
df_clean_to_stat <- df_clean_to_stat %>%
mutate(Metabolite.name = sub(";.*", "", Metabolite_name))
# Step 2: Group by the cleaned `Metabolite.name` and calculate the average for each unique metabolite
df_clean_to_stat_v1 <- df_clean_to_stat %>%
group_by(Metabolite.name) %>%
summarise(across(everything(), mean, na.rm = TRUE)) %>%
ungroup()
# Step 1: Calculate the average of the blank columns for each metabolite in df_below_Q3
df_with_blank_avg <- df_below_Q3 %>%
rowwise() %>%
mutate(Average_Blank = mean(c_across(starts_with("Blank_")), na.rm = TRUE))
# Step 2: Define sample columns, excluding `Pool_1`, `Pool_2`, and all `Blank` columns
sample_columns <- setdiff(names(df_below_Q3), c("Metabolite_name", "Blank_1", "Blank_2", "Blank_3", "Blank_4", "Pool_1", "Pool_2"))
# Step 3: Subtract the average blank value from each sample column to remove background noise
df_clean_to_stat <- df_with_blank_avg %>%
mutate(across(all_of(sample_columns), ~ . - Average_Blank)) %>%
select(Metabolite_name, all_of(sample_columns))  # Keep only the relevant columns for downstream analysis
# View the resulting dataframe
str(df_clean_to_stat)
# Step 1: Clean `Metabolite.name` by removing extra information after ";"
df_clean_to_stat_v1 <- df_clean_to_stat %>%
mutate(Metabolite_name = str_remove(Metabolite_name, ";.*"))
# Step 2: Group by the cleaned `Metabolite.name` and calculate the average for each unique metabolite
df_clean_to_stat_v1 <- df_clean_to_stat_v1 %>%
group_by(Metabolite_name) %>%
summarise(across(everything(), mean, na.rm = TRUE)) %>%
ungroup()
# Step 3: Reshape to long format for averaging replicates without duplicate column names
df_clean_to_stat_v1_long <- df_clean_to_stat_v1 %>%
pivot_longer(cols = -Metabolite_name, names_to = "Sample", values_to = "Value")
# Step 4: Extract base sample names by removing replicate suffixes
df_clean_to_stat_v1_long <- df_clean_to_stat_v1_long %>%
mutate(Base_Sample = str_remove(Sample, "_\\d+$"))
# Step 5: Group by `Metabolite_name` and `Base_Sample`, then calculate the average for each base sample
df_clean_to_stat_v2 <- df_clean_to_stat_v1_long %>%
group_by(Metabolite_name, Base_Sample) %>%
summarise(Average_Value = mean(Value, na.rm = TRUE), .groups = "drop")
# Step 6: Pivot back to wide format to get a final data frame with averaged values for each base sample
df_clean_to_stat_v2 <- df_clean_to_stat_v2 %>%
pivot_wider(names_from = Base_Sample, values_from = Average_Value)
# View the resulting dataframe structure
str(df_clean_to_stat_v2)
# Step 7: Prepare data for heatmap plotting
# Truncate Metabolite.name to the first 30 characters for readability
df_clean_to_stat_v2 <- df_clean_to_stat_v2 %>%
mutate(Metabolite_name = str_sub(Metabolite_name, 1, 30))
# Convert to matrix format for heatmap
heatmap_matrix <- df_clean_to_stat_v2 %>%
column_to_rownames(var = "Metabolite_name") %>%
as.matrix()
# Step 8: Plot the heatmap
pheatmap(heatmap_matrix,
scale = "row",  # Normalize each row for better visualization
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(50),
main = "Heatmap of Metabolite Data (Averaged Across Replicates)",
fontsize_row = 6)  # Adjust font size for readability
# Save heatmap as a PDF with high resolution
pdf("Heatmap_Metabolite_Data.pdf", width = 12, height = 10)  # Set appropriate width and height
pheatmap(heatmap_matrix,
scale = "row",  # Normalize each row for better visualization
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(50),
main = "Heatmap of Metabolite Data (Averaged Across Replicates)",
fontsize_row = 6)  # Adjust font size for row labels
dev.off()  # Close the PDF device
# Save heatmap as a high-resolution JPEG
jpeg("Heatmap_Metabolite_Data.jpg", width = 1200, height = 1000, res = 300)  # Set high resolution with res = 300
pheatmap(heatmap_matrix,
scale = "row",  # Normalize each row for better visualization
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(50),
main = "Heatmap of Metabolite Data (Averaged Across Replicates)",
fontsize_row = 6)  # Adjust font size for row labels
dev.off()  # Close the JPEG device
# Save heatmap as a high-resolution JPEG
jpeg("Heatmap_Metabolite_Data.jpg", width = 1200, height = 1000, res = 300)  # Set high resolution with res = 300
pheatmap(heatmap_matrix,
scale = "row",  # Normalize each row for better visualization
clustering_distance_rows = "euclidean",
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(50),
main = "Heatmap of Metabolite Data (Averaged Across Replicates)",
fontsize_row = 6)  # Adjust font size for row labels
dev.off()  # Close the JPEG device
